// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: labels.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLabel = `-- name: CreateLabel :one
INSERT INTO labels (user_id, name)
VALUES ($1, $2)
RETURNING id, user_id, name, created_at, updated_at, deleted_at
`

type CreateLabelParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Name   string      `json:"name"`
}

func (q *Queries) CreateLabel(ctx context.Context, arg CreateLabelParams) (Label, error) {
	row := q.db.QueryRow(ctx, createLabel, arg.UserID, arg.Name)
	var i Label
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteTaskLabelsByLabelID = `-- name: DeleteTaskLabelsByLabelID :execrows
DELETE FROM task_labels
WHERE label_id = $1
`

func (q *Queries) DeleteTaskLabelsByLabelID(ctx context.Context, labelID pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteTaskLabelsByLabelID, labelID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getLabelByID = `-- name: GetLabelByID :one
SELECT id, user_id, name, created_at, updated_at, deleted_at
FROM labels
WHERE id = $1
  AND user_id = $2
  AND deleted_at IS NULL
LIMIT 1
`

type GetLabelByIDParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetLabelByID(ctx context.Context, arg GetLabelByIDParams) (Label, error) {
	row := q.db.QueryRow(ctx, getLabelByID, arg.ID, arg.UserID)
	var i Label
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getLabelsByIDs = `-- name: GetLabelsByIDs :many
SELECT id, user_id, name, created_at, updated_at, deleted_at
FROM labels
WHERE user_id = $1
  AND id = ANY($2::uuid[])
  AND deleted_at IS NULL
ORDER BY created_at DESC, id DESC
`

type GetLabelsByIDsParams struct {
	UserID  pgtype.UUID   `json:"user_id"`
	Column2 []pgtype.UUID `json:"column_2"`
}

func (q *Queries) GetLabelsByIDs(ctx context.Context, arg GetLabelsByIDsParams) ([]Label, error) {
	rows, err := q.db.Query(ctx, getLabelsByIDs, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Label{}
	for rows.Next() {
		var i Label
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabels = `-- name: ListLabels :many
SELECT id, user_id, name, created_at, updated_at, deleted_at
FROM labels
WHERE user_id = $1
  AND deleted_at IS NULL
  AND (
    NOT $2::boolean
    OR (created_at, id) < ($3::timestamptz, $4::uuid)
  )
ORDER BY created_at DESC, id DESC
LIMIT $5
`

type ListLabelsParams struct {
	UserID  pgtype.UUID        `json:"user_id"`
	Column2 bool               `json:"column_2"`
	Column3 pgtype.Timestamptz `json:"column_3"`
	Column4 pgtype.UUID        `json:"column_4"`
	Limit   int32              `json:"limit"`
}

func (q *Queries) ListLabels(ctx context.Context, arg ListLabelsParams) ([]Label, error) {
	rows, err := q.db.Query(ctx, listLabels,
		arg.UserID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Label{}
	for rows.Next() {
		var i Label
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLabelsByTaskID = `-- name: ListLabelsByTaskID :many
SELECT l.id, l.user_id, l.name, l.created_at, l.updated_at, l.deleted_at
FROM labels l
JOIN task_labels tl ON tl.label_id = l.id
WHERE tl.task_id = $1
  AND l.user_id = $2
  AND l.deleted_at IS NULL
ORDER BY l.created_at DESC, l.id DESC
`

type ListLabelsByTaskIDParams struct {
	TaskID pgtype.UUID `json:"task_id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) ListLabelsByTaskID(ctx context.Context, arg ListLabelsByTaskIDParams) ([]Label, error) {
	rows, err := q.db.Query(ctx, listLabelsByTaskID, arg.TaskID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Label{}
	for rows.Next() {
		var i Label
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteLabel = `-- name: SoftDeleteLabel :one
UPDATE labels
SET
  deleted_at = NOW(),
  updated_at = NOW()
WHERE id = $1
  AND user_id = $2
  AND deleted_at IS NULL
RETURNING id, deleted_at
`

type SoftDeleteLabelParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

type SoftDeleteLabelRow struct {
	ID        pgtype.UUID        `json:"id"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) SoftDeleteLabel(ctx context.Context, arg SoftDeleteLabelParams) (SoftDeleteLabelRow, error) {
	row := q.db.QueryRow(ctx, softDeleteLabel, arg.ID, arg.UserID)
	var i SoftDeleteLabelRow
	err := row.Scan(&i.ID, &i.DeletedAt)
	return i, err
}

const updateLabel = `-- name: UpdateLabel :one
UPDATE labels
SET
  name = $3,
  updated_at = NOW()
WHERE id = $1
  AND user_id = $2
  AND deleted_at IS NULL
RETURNING id, user_id, name, created_at, updated_at, deleted_at
`

type UpdateLabelParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
	Name   string      `json:"name"`
}

func (q *Queries) UpdateLabel(ctx context.Context, arg UpdateLabelParams) (Label, error) {
	row := q.db.QueryRow(ctx, updateLabel, arg.ID, arg.UserID, arg.Name)
	var i Label
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
