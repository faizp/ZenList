// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tasks.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (
  user_id,
  project_id,
  parent_task_id,
  title,
  description,
  status,
  priority,
  start_at,
  due_at,
  completed_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, user_id, project_id, parent_task_id, title, description, status, priority, start_at, due_at, completed_at, created_at, updated_at, deleted_at
`

type CreateTaskParams struct {
	UserID       pgtype.UUID        `json:"user_id"`
	ProjectID    pgtype.UUID        `json:"project_id"`
	ParentTaskID pgtype.UUID        `json:"parent_task_id"`
	Title        string             `json:"title"`
	Description  *string            `json:"description"`
	Status       string             `json:"status"`
	Priority     string             `json:"priority"`
	StartAt      pgtype.Timestamptz `json:"start_at"`
	DueAt        pgtype.Timestamptz `json:"due_at"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.UserID,
		arg.ProjectID,
		arg.ParentTaskID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.Priority,
		arg.StartAt,
		arg.DueAt,
		arg.CompletedAt,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.ParentTaskID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.StartAt,
		&i.DueAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT id, user_id, project_id, parent_task_id, title, description, status, priority, start_at, due_at, completed_at, created_at, updated_at, deleted_at
FROM tasks
WHERE id = $1
  AND user_id = $2
  AND deleted_at IS NULL
LIMIT 1
`

type GetTaskByIDParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetTaskByID(ctx context.Context, arg GetTaskByIDParams) (Task, error) {
	row := q.db.QueryRow(ctx, getTaskByID, arg.ID, arg.UserID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.ParentTaskID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.StartAt,
		&i.DueAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listRootTasks = `-- name: ListRootTasks :many
SELECT id, user_id, project_id, parent_task_id, title, description, status, priority, start_at, due_at, completed_at, created_at, updated_at, deleted_at
FROM tasks
WHERE user_id = $1
  AND project_id = $2
  AND parent_task_id IS NULL
  AND deleted_at IS NULL
  AND (cardinality($3::text[]) = 0 OR status = ANY($3::text[]))
  AND (cardinality($4::text[]) = 0 OR priority = ANY($4::text[]))
  AND (
    NOT $5::boolean
    OR (created_at, id) < ($6::timestamptz, $7::uuid)
  )
ORDER BY created_at DESC, id DESC
LIMIT $8
`

type ListRootTasksParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	ProjectID pgtype.UUID        `json:"project_id"`
	Column3   []string           `json:"column_3"`
	Column4   []string           `json:"column_4"`
	Column5   bool               `json:"column_5"`
	Column6   pgtype.Timestamptz `json:"column_6"`
	Column7   pgtype.UUID        `json:"column_7"`
	Limit     int32              `json:"limit"`
}

func (q *Queries) ListRootTasks(ctx context.Context, arg ListRootTasksParams) ([]Task, error) {
	rows, err := q.db.Query(ctx, listRootTasks,
		arg.UserID,
		arg.ProjectID,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.ParentTaskID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.StartAt,
			&i.DueAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubtasks = `-- name: ListSubtasks :many
SELECT id, user_id, project_id, parent_task_id, title, description, status, priority, start_at, due_at, completed_at, created_at, updated_at, deleted_at
FROM tasks
WHERE user_id = $1
  AND project_id = $2
  AND parent_task_id = $3
  AND deleted_at IS NULL
  AND (cardinality($4::text[]) = 0 OR status = ANY($4::text[]))
  AND (cardinality($5::text[]) = 0 OR priority = ANY($5::text[]))
  AND (
    NOT $6::boolean
    OR (created_at, id) < ($7::timestamptz, $8::uuid)
  )
ORDER BY created_at DESC, id DESC
LIMIT $9
`

type ListSubtasksParams struct {
	UserID       pgtype.UUID        `json:"user_id"`
	ProjectID    pgtype.UUID        `json:"project_id"`
	ParentTaskID pgtype.UUID        `json:"parent_task_id"`
	Column4      []string           `json:"column_4"`
	Column5      []string           `json:"column_5"`
	Column6      bool               `json:"column_6"`
	Column7      pgtype.Timestamptz `json:"column_7"`
	Column8      pgtype.UUID        `json:"column_8"`
	Limit        int32              `json:"limit"`
}

func (q *Queries) ListSubtasks(ctx context.Context, arg ListSubtasksParams) ([]Task, error) {
	rows, err := q.db.Query(ctx, listSubtasks,
		arg.UserID,
		arg.ProjectID,
		arg.ParentTaskID,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.ParentTaskID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.StartAt,
			&i.DueAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubtasksByParentID = `-- name: ListSubtasksByParentID :many
SELECT id, user_id, project_id, parent_task_id, title, description, status, priority, start_at, due_at, completed_at, created_at, updated_at, deleted_at
FROM tasks
WHERE user_id = $1
  AND parent_task_id = $2
  AND deleted_at IS NULL
ORDER BY created_at DESC, id DESC
`

type ListSubtasksByParentIDParams struct {
	UserID       pgtype.UUID `json:"user_id"`
	ParentTaskID pgtype.UUID `json:"parent_task_id"`
}

func (q *Queries) ListSubtasksByParentID(ctx context.Context, arg ListSubtasksByParentIDParams) ([]Task, error) {
	rows, err := q.db.Query(ctx, listSubtasksByParentID, arg.UserID, arg.ParentTaskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProjectID,
			&i.ParentTaskID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.StartAt,
			&i.DueAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteDirectSubtasks = `-- name: SoftDeleteDirectSubtasks :execrows
UPDATE tasks
SET
  deleted_at = NOW(),
  updated_at = NOW()
WHERE parent_task_id = $1
  AND user_id = $2
  AND deleted_at IS NULL
`

type SoftDeleteDirectSubtasksParams struct {
	ParentTaskID pgtype.UUID `json:"parent_task_id"`
	UserID       pgtype.UUID `json:"user_id"`
}

func (q *Queries) SoftDeleteDirectSubtasks(ctx context.Context, arg SoftDeleteDirectSubtasksParams) (int64, error) {
	result, err := q.db.Exec(ctx, softDeleteDirectSubtasks, arg.ParentTaskID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const softDeleteTask = `-- name: SoftDeleteTask :one
UPDATE tasks
SET
  deleted_at = NOW(),
  updated_at = NOW()
WHERE id = $1
  AND user_id = $2
  AND deleted_at IS NULL
RETURNING id, deleted_at
`

type SoftDeleteTaskParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

type SoftDeleteTaskRow struct {
	ID        pgtype.UUID        `json:"id"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) SoftDeleteTask(ctx context.Context, arg SoftDeleteTaskParams) (SoftDeleteTaskRow, error) {
	row := q.db.QueryRow(ctx, softDeleteTask, arg.ID, arg.UserID)
	var i SoftDeleteTaskRow
	err := row.Scan(&i.ID, &i.DeletedAt)
	return i, err
}

const softDeleteTasksByProject = `-- name: SoftDeleteTasksByProject :execrows
UPDATE tasks
SET
  deleted_at = NOW(),
  updated_at = NOW()
WHERE project_id = $1
  AND user_id = $2
  AND deleted_at IS NULL
`

type SoftDeleteTasksByProjectParams struct {
	ProjectID pgtype.UUID `json:"project_id"`
	UserID    pgtype.UUID `json:"user_id"`
}

func (q *Queries) SoftDeleteTasksByProject(ctx context.Context, arg SoftDeleteTasksByProjectParams) (int64, error) {
	result, err := q.db.Exec(ctx, softDeleteTasksByProject, arg.ProjectID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateTask = `-- name: UpdateTask :one
UPDATE tasks
SET
  title = $3,
  description = $4,
  status = $5,
  priority = $6,
  start_at = $7,
  due_at = $8,
  completed_at = $9,
  updated_at = NOW()
WHERE id = $1
  AND user_id = $2
  AND deleted_at IS NULL
RETURNING id, user_id, project_id, parent_task_id, title, description, status, priority, start_at, due_at, completed_at, created_at, updated_at, deleted_at
`

type UpdateTaskParams struct {
	ID          pgtype.UUID        `json:"id"`
	UserID      pgtype.UUID        `json:"user_id"`
	Title       string             `json:"title"`
	Description *string            `json:"description"`
	Status      string             `json:"status"`
	Priority    string             `json:"priority"`
	StartAt     pgtype.Timestamptz `json:"start_at"`
	DueAt       pgtype.Timestamptz `json:"due_at"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, updateTask,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.Priority,
		arg.StartAt,
		arg.DueAt,
		arg.CompletedAt,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProjectID,
		&i.ParentTaskID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.StartAt,
		&i.DueAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
